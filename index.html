<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinematic Anime Energy Effect</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505; /* High contrast dark background */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <!-- Import Maps for Three.js ES Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- 1. SETUP SCENE, CAMERA, RENDERER ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020005, 0.03); // Subtle dark purple fog for depth

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // --- 2. POST-PROCESSING (BLOOM) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Resolution, strength, radius, threshold
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.8, 0.1);
        composer.addPass(bloomPass);

        const outputPass = new OutputPass();
        composer.addPass(outputPass);

        // --- 3. SHADER CHUNKS (NOISE) ---
        const noiseChunk = `
            // Ashima Simplex 3D Noise 
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;

                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );

                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;

                i = mod289(i);
                vec4 p = permute( permute( permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;

                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );

                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);

                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );

                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));

                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);

                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;

                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
        `;

        // --- 4. PLASMA CORE (Turbulent Sphere) ---
        const coreGeometry = new THREE.IcosahedronGeometry(2.5, 64);
        const coreMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColorMain: { value: new THREE.Color(0xff00ff) }, // Magenta
                uColorHighlight: { value: new THREE.Color(0xffffff) }, // White
                uColorDark: { value: new THREE.Color(0x4a00e0) } // Deep Purple
            },
            vertexShader: `
                ${noiseChunk}
                uniform float uTime;
                varying vec2 vUv;
                varying float vNoise;
                varying vec3 vNormal;
                varying vec3 vViewPosition;

                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    
                    // Complex noise for turbulent plasma
                    float n1 = snoise(position * 1.5 + uTime * 1.2);
                    float n2 = snoise(position * 3.0 - uTime * 1.5) * 0.5;
                    float n3 = snoise(position * 6.0 + uTime * 2.0) * 0.25;
                    vNoise = n1 + n2 + n3;
                    
                    // Displace vertices
                    vec3 displacedPosition = position + normal * (vNoise * 0.6);
                    
                    vec4 mvPosition = modelViewMatrix * vec4(displacedPosition, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 uColorMain;
                uniform vec3 uColorHighlight;
                uniform vec3 uColorDark;
                varying vec2 vUv;
                varying float vNoise;
                varying vec3 vNormal;
                varying vec3 vViewPosition;

                void main() {
                    // Fresnel calculation for outer glow
                    vec3 normal = normalize(vNormal);
                    vec3 viewDir = normalize(vViewPosition);
                    float fresnel = dot(normal, viewDir);
                    fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                    fresnel = pow(fresnel, 2.0);

                    // Map noise to colors
                    float mixVal = smoothstep(-1.0, 1.0, vNoise);
                    vec3 color = mix(uColorDark, uColorMain, mixVal);
                    
                    // Add intense white hot spots based on noise
                    float highlightVal = smoothstep(0.4, 0.8, vNoise);
                    color = mix(color, uColorHighlight, highlightVal);
                    
                    // Amplify edges via fresnel
                    color += fresnel * uColorMain * 1.5;

                    // Boost overall intensity for Bloom Pass
                    color *= 1.8;

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const plasmaCore = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(plasmaCore);

        // Core Inner Glow (Solid bright center)
        const innerGlowGeo = new THREE.SphereGeometry(2.0, 32, 32);
        const innerGlowMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });
        const innerGlow = new THREE.Mesh(innerGlowGeo, innerGlowMat);
        scene.add(innerGlow);


        // --- 5. GPU PARTICLES (Floating Holographic Fragments) ---
        const particleCount = 12000;
        const particleGeometry = new THREE.BufferGeometry();
        
        const pPositions = new Float32Array(particleCount * 3);
        const pRandoms = new Float32Array(particleCount * 3);
        const pSizes = new Float32Array(particleCount);

        for(let i = 0; i < particleCount; i++) {
            // Distribute points spherically but heavily concentrated near the center
            const r = 2.0 + Math.pow(Math.random(), 3.0) * 15.0; // Distance from center
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            pPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            pPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            pPositions[i*3+2] = r * Math.cos(phi);

            // Random values for animation speed, amplitude, phase
            pRandoms[i*3] = Math.random();
            pRandoms[i*3+1] = Math.random();
            pRandoms[i*3+2] = Math.random();

            pSizes[i] = Math.random() * 0.5 + 0.1;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(pPositions, 3));
        particleGeometry.setAttribute('aRandom', new THREE.BufferAttribute(pRandoms, 3));
        particleGeometry.setAttribute('aSize', new THREE.BufferAttribute(pSizes, 1));

        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor1: { value: new THREE.Color(0xff66ff) },
                uColor2: { value: new THREE.Color(0x88bbff) },
                uPixelRatio: { value: renderer.getPixelRatio() }
            },
            vertexShader: `
                ${noiseChunk}
                uniform float uTime;
                uniform float uPixelRatio;
                attribute vec3 aRandom;
                attribute float aSize;
                
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vec3 pos = position;
                    
                    // Orbiting motion
                    float angle = uTime * (aRandom.x * 2.0 - 1.0) * 0.5;
                    float s = sin(angle);
                    float c = cos(angle);
                    mat2 rot = mat2(c, -s, s, c);
                    pos.xz = rot * pos.xz;
                    pos.xy = rot * pos.xy;
                    
                    // Turbulence
                    float noise = snoise(pos * 0.5 + uTime * 0.5);
                    pos += normalize(pos) * noise * 2.0;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // Size attenuation
                    gl_PointSize = (aSize * 60.0 * uPixelRatio) / -mvPosition.z;
                    
                    // Color mix based on distance and random
                    float dist = length(pos);
                    vColor = mix(vec3(1.0, 0.4, 1.0), vec3(0.4, 0.8, 1.0), aRandom.y);
                    
                    // Fade out particles far away
                    vAlpha = smoothstep(18.0, 2.0, dist) * (0.3 + 0.7 * aRandom.z);
                    vAlpha *= smoothstep(0.0, 2.0, dist); // Fade center so core shines
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    // Soft circular particle
                    vec2 center = gl_PointCoord - 0.5;
                    float dist = length(center);
                    if(dist > 0.5) discard;
                    
                    // Soft edge glow
                    float strength = 1.0 - (dist * 2.0);
                    strength = pow(strength, 1.5);
                    
                    gl_FragColor = vec4(vColor * strength * 2.0, vAlpha * strength);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);


        // --- 6. SHARP LIGHTNING / ENERGY STREAKS ---
        // Using InstancedMesh to draw hundreds of glowing planes radiating outwards
        const streakCount = 400;
        const streakGeo = new THREE.PlaneGeometry(0.1, 10.0);
        // Translate so origin is at the base
        streakGeo.translate(0, 5.0, 0);

        const streakMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0xffaaff) } // Bright pink-white
            },
            vertexShader: `
                ${noiseChunk}
                uniform float uTime;
                attribute vec3 aRandomSeed;
                
                varying float vAlpha;
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    
                    // Fast chaotic noise for lightning jitter
                    float flicker = snoise(vec3(aRandomSeed.x * 10.0, uTime * 15.0, aRandomSeed.z));
                    float scaleZ = smoothstep(0.0, 1.0, (flicker + 1.0) * 0.5) * aRandomSeed.y * 1.5;
                    
                    // Visibility / flashing
                    float visible = step(0.6, snoise(vec3(aRandomSeed.y * 20.0, uTime * 8.0, aRandomSeed.x)));
                    vAlpha = visible * (0.5 + 0.5 * flicker);

                    // Stretch and scale the mesh
                    vec3 pos = position;
                    pos.y *= scaleZ; // Stretch outward
                    
                    // Add jagged displacement to the plane vertices
                    if(pos.y > 0.1) {
                        float jagged = snoise(vec3(pos.y * 2.0, uTime * 20.0, aRandomSeed.z)) * 0.3;
                        pos.x += jagged;
                    }

                    vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying float vAlpha;
                varying vec2 vUv;

                void main() {
                    // Fade out towards the tip and edges
                    float tipFade = 1.0 - vUv.y;
                    float edgeFade = sin(vUv.x * 3.14159);
                    
                    float intensity = tipFade * edgeFade * vAlpha;
                    
                    // Super bright core of the beam
                    vec3 finalColor = uColor * 3.0; 
                    
                    gl_FragColor = vec4(finalColor * intensity, intensity);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        const streaks = new THREE.InstancedMesh(streakGeo, streakMat, streakCount);
        const dummy = new THREE.Object3D();
        const streakRandoms = new Float32Array(streakCount * 3);

        for(let i = 0; i < streakCount; i++) {
            // Random orientation around the sphere
            dummy.position.set(0, 0, 0);
            
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            dummy.rotation.x = phi;
            dummy.rotation.y = theta;
            dummy.rotation.z = Math.random() * Math.PI;
            
            // Push them slightly out from the absolute center
            dummy.translateY(1.5);
            dummy.updateMatrix();
            
            streaks.setMatrixAt(i, dummy.matrix);
            
            // Random seeds for shader noise
            streakRandoms[i*3] = Math.random();
            streakRandoms[i*3+1] = Math.random() * 2.0 + 0.5; // Scale modifier
            streakRandoms[i*3+2] = Math.random();
        }
        streaks.geometry.setAttribute('aRandomSeed', new THREE.InstancedBufferAttribute(streakRandoms, 3));
        scene.add(streaks);


        // --- 7. ANIMATION LOOP ---
        const clock = new THREE.Clock();
        
        // Subtle camera shake parameters
        const baseCameraPos = new THREE.Vector3(0, 0, 15);

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Update Uniforms
            coreMaterial.uniforms.uTime.value = elapsedTime;
            particleMaterial.uniforms.uTime.value = elapsedTime;
            streakMat.uniforms.uTime.value = elapsedTime;

            // Rotate core slightly
            plasmaCore.rotation.y = elapsedTime * 0.2;
            plasmaCore.rotation.z = elapsedTime * 0.15;
            
            // Pulse inner glow
            const pulse = Math.sin(elapsedTime * 8.0) * 0.05 + 1.0;
            innerGlow.scale.set(pulse, pulse, pulse);

            // Rotate entire streak system slowly
            streaks.rotation.y = elapsedTime * 0.1;
            streaks.rotation.z = elapsedTime * -0.05;

            // Subtle Camera Shake for High Energy Feel
            const shakeAmount = 0.03;
            camera.position.x = baseCameraPos.x + (Math.random() - 0.5) * shakeAmount;
            camera.position.y = baseCameraPos.y + (Math.random() - 0.5) * shakeAmount;
            
            // Render via composer for bloom
            composer.render();
        }

        animate();

        // --- 8. RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            particleMaterial.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        });

    </script>
</body>
</html>
