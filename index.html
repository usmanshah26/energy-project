<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ultra Energy Core</title>
<style>
body { margin:0; overflow:hidden; background:black; }
canvas { display:block; }
</style>
</head>
<body>

<script type="module">

import * as THREE from "https://unpkg.com/three@0.152.2/build/three.module.js";
import { EffectComposer } from "https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// BLOOM
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(innerWidth, innerHeight),
    1.5,
    0.8,
    0.2
);
composer.addPass(bloomPass);

// CORE SHADER MATERIAL
const coreMaterial = new THREE.ShaderMaterial({
    uniforms: {
        time: { value: 0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
    `,
    fragmentShader: `
        uniform float time;
        varying vec2 vUv;

        void main(){
            float strength = sin(vUv.y*10.0 + time*3.0);
            float glow = abs(strength);
            vec3 color = vec3(0.6,0.0,1.0) + glow*0.5;
            gl_FragColor = vec4(color,1.0);
        }
    `
});

const core = new THREE.Mesh(
    new THREE.SphereGeometry(1,128,128),
    coreMaterial
);
scene.add(core);

// OUTER RING
const ring = new THREE.Mesh(
    new THREE.TorusGeometry(1.6,0.05,32,200),
    new THREE.MeshBasicMaterial({color:0xff00ff})
);
ring.rotation.x = Math.PI/2;
scene.add(ring);

// PARTICLE AURA
const particlesGeometry = new THREE.BufferGeometry();
const particleCount = 2000;
const positions = new Float32Array(particleCount * 3);

for(let i=0;i<particleCount;i++){
    positions[i*3] = (Math.random()-0.5)*6;
    positions[i*3+1] = (Math.random()-0.5)*6;
    positions[i*3+2] = (Math.random()-0.5)*6;
}

particlesGeometry.setAttribute("position", new THREE.BufferAttribute(positions,3));

const particlesMaterial = new THREE.PointsMaterial({
    color:0xff00ff,
    size:0.03
});

const particles = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particles);

// ANIMATION
function animate(){
    requestAnimationFrame(animate);

    coreMaterial.uniforms.time.value += 0.05;
    core.rotation.y += 0.01;
    ring.rotation.z += 0.02;

    composer.render();
}

animate();

// RESIZE
window.addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
});

</script>

</body>
</html>
