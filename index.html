<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hollow Purple - Gesture Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #05000a; font-family: 'Courier New', monospace; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 2; transform: scaleX(-1); } /* Mirror Effect */
        video { display: none; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #b026ff; text-shadow: 0 0 5px #b026ff;
            pointer-events: none; mix-blend-mode: screen;
        }
        .hud-row { margin-bottom: 8px; font-weight: bold; font-size: 14px; display: flex; align-items: center; gap: 10px; }
        .bar-container { width: 100px; height: 6px; background: rgba(255,255,255,0.1); border: 1px solid #b026ff; }
        .bar-fill { height: 100%; background: #b026ff; width: 0%; transition: width 0.1s; box-shadow: 0 0 8px #b026ff; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d896ff; font-size: 16px; z-index: 100; letter-spacing: 2px;
            background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #b026ff;
        }
        
        #error-msg {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; background: #000; padding: 20px; border: 1px solid red; z-index: 200;
        }
    </style>
    
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">INITIALIZING NEURAL INTERFACE...</div>
    <div id="error-msg">WebGL Error: Your browser blocked the 3D context. Please restart Chrome or try a different browser.</div>

    <div id="ui-layer">
        <div class="hud-row">
            <span>SYNC</span>
            <div class="bar-container"><div id="sync-bar" class="bar-fill"></div></div>
        </div>
        <div class="hud-row">
            <span>OUTPUT</span>
            <div class="bar-container"><div id="energy-bar" class="bar-fill"></div></div>
        </div>
        <div class="hud-row">MODE: <span id="mode-text">SCANNING</span></div>
    </div>

    <video id="input-video" playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIG ---
        const CONFIG = {
            particles: 4000, // Reduced slightly for stability
            bloomStr: 2.0,
            bloomRad: 0.5,
            bloomThres: 0.1,
            colors: {
                base: new THREE.Color(0x6600ff),  // Purple
                core: new THREE.Color(0xffffff),  // White
                glow: new THREE.Color(0xff0066)   // Pink/Red
            }
        };

        const STATE = {
            handActive: false,
            gesture: 'IDLE', // IDLE, CHARGE, RELEASE, SPLIT
            energy: 0.0,
            handPos: new THREE.Vector3(),
            smoothPos: new THREE.Vector3(),
            pinchDist: 1.0
        };

        let scene, camera, renderer, composer;
        let coreMesh, particles, lightning, shockwave;
        let videoTexture, videoMesh;

        // --- SHADERS ---
        const NOISE_GLSL = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
        `;

        function init() {
            try {
                // 1. Scene Setup
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.z = 5;

                // 2. Renderer (Safe Mode)
                // Removed 'powerPreference: high-performance' to avoid context loss on heavy loads
                renderer = new THREE.WebGLRenderer({ 
                    antialias: false, 
                    alpha: true,
                    stencil: false,
                    depth: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap pixel ratio for performance
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                renderer.toneMapping = THREE.ReinhardToneMapping;
                document.body.appendChild(renderer.domElement);

                // 3. Post Processing
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    CONFIG.bloomStr, CONFIG.bloomRad, CONFIG.bloomThres
                );
                
                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // 4. Background Video
                const video = document.getElementById('input-video');
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.colorSpace = THREE.SRGBColorSpace;
                
                const bgGeo = new THREE.PlaneGeometry(16, 9);
                bgGeo.scale(1.45, 1.45, 1);
                const bgMat = new THREE.MeshBasicMaterial({ map: videoTexture, depthWrite: false });
                videoMesh = new THREE.Mesh(bgGeo, bgMat);
                videoMesh.position.z = -10;
                scene.add(videoMesh);

                createVFX();
                window.addEventListener('resize', onResize);
                startMediaPipe();
                animate();

            } catch (e) {
                console.error(e);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-msg').style.display = 'block';
            }
        }

        function createVFX() {
            // A. Plasma Core
            const coreGeo = new THREE.IcosahedronGeometry(0.8, 30);
            const coreMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uEnergy: { value: 0 },
                    uColor1: { value: CONFIG.colors.base },
                    uColor2: { value: CONFIG.colors.glow }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uEnergy;
                    varying vec3 vNormal;
                    varying float vNoise;
                    ${NOISE_GLSL}
                    void main() {
                        vNormal = normal;
                        float n = snoise(position * 3.0 + uTime);
                        vNoise = n;
                        vec3 pos = position + normal * n * (0.1 + uEnergy * 0.3);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor1;
                    uniform vec3 uColor2;
                    uniform float uEnergy;
                    varying vec3 vNormal;
                    varying float vNoise;
                    void main() {
                        vec3 viewDir = normalize(cameraPosition - vNormal); // Cheap approx
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0,0,1)), 3.0);
                        vec3 col = mix(uColor1, uColor2, vNoise * 0.5 + 0.5);
                        col += fresnel * 2.0;
                        col += uEnergy * vec3(0.5, 0.0, 0.5);
                        gl_FragColor = vec4(col, 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            coreMesh = new THREE.Mesh(coreGeo, coreMat);
            scene.add(coreMesh);

            // B. Particles
            const pCount = CONFIG.particles;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(pCount * 3);
            const pRand = new Float32Array(pCount);
            
            for(let i=0; i<pCount; i++) {
                const r = 2.0 + Math.random() * 3.0;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                pPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                pPos[i*3+2] = r * Math.cos(phi);
                pRand[i] = Math.random();
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            pGeo.setAttribute('aRand', new THREE.BufferAttribute(pRand, 1));

            const pMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uBurst: { value: 0 },
                    uColor: { value: CONFIG.colors.base }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uBurst;
                    attribute float aRand;
                    varying float vAlpha;
                    void main() {
                        vec3 pos = position;
                        // Rotation
                        float t = uTime * (0.2 + aRand * 0.5);
                        float c = cos(t); float s = sin(t);
                        pos.xz = mat2(c, -s, s, c) * pos.xz;
                        
                        // Burst expansion
                        pos += normalize(position) * uBurst * 15.0;
                        
                        vec4 mv = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mv;
                        gl_PointSize = (4.0 + uBurst * 20.0) * (5.0 / -mv.z);
                        vAlpha = 1.0 - length(pos)/8.0;
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying float vAlpha;
                    void main() {
                        if (length(gl_PointCoord - 0.5) > 0.5) discard;
                        gl_FragColor = vec4(uColor + 0.5, vAlpha * 0.8);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            particles = new THREE.Points(pGeo, pMat);
            scene.add(particles);

            // C. Lightning Arcs
            const lGeo = new THREE.TorusGeometry(1.5, 0.02, 8, 50);
            const lMat = new THREE.MeshBasicMaterial({ 
                color: 0xccffff, transparent: true, blending: THREE.AdditiveBlending 
            });
            lightning = new THREE.Group();
            for(let i=0; i<4; i++){
                const m = new THREE.Mesh(lGeo, lMat);
                m.rotation.set(Math.random()*3, Math.random()*3, 0);
                lightning.add(m);
            }
            scene.add(lightning);

            // D. Shockwave
            shockwave = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.5, 64),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, side: THREE.DoubleSide })
            );
            scene.add(shockwave);
        }

        function startMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1, // 0 = Lite, 1 = Full. Using 1 for better accuracy.
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640, // Reduced from 1280 for performance stability
                height: 360
            });
            cameraUtils.start();
        }

        function onHandResults(results) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('sync-bar').style.width = '100%';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const marks = results.multiHandLandmarks[0];
                STATE.handActive = true;
                
                // Position Mapping
                // MediaPipe is normalized 0-1.
                // We map this to our scene frustum roughly.
                // Center is 0.5, 0.5
                const x = (0.5 - marks[9].x) * 16; // x16 for width
                const y = (0.5 - marks[9].y) * 9;  // x9 for height
                const z = -Math.abs(marks[0].z) * 10; 
                
                STATE.handPos.set(x, y, 0);

                // Gesture Logic
                const thumb = marks[4];
                const index = marks[8];
                const pinch = Math.hypot(index.x - thumb.x, index.y - thumb.y);
                STATE.pinchDist = pinch;

                // Simple State Machine
                const tips = [8, 12, 16, 20];
                let folded = 0;
                tips.forEach((t, i) => {
                    if (marks[t].y > marks[t-2].y) folded++;
                });

                if (pinch < 0.05) {
                    STATE.gesture = 'CHARGE';
                } else if (folded === 4) {
                     // Fist - usually for explosion trigger but we wait for release
                     // Actually let's map Fist -> Charge, Release -> Boom
                     if (STATE.energy > 0.8) STATE.gesture = 'RELEASE';
                } else {
                    STATE.gesture = 'IDLE';
                }

                document.getElementById('mode-text').innerText = STATE.gesture;
            } else {
                STATE.handActive = false;
                document.getElementById('sync-bar').style.width = '10%';
            }
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // Logic Update
            STATE.smoothPos.lerp(STATE.handPos, 0.1);

            if (STATE.handActive) {
                coreMesh.visible = true;
                coreMesh.position.copy(STATE.smoothPos);
                lightning.position.copy(STATE.smoothPos);
                particles.position.copy(STATE.smoothPos);
                shockwave.position.copy(STATE.smoothPos);

                // Charge Logic
                if (STATE.gesture === 'CHARGE') {
                    STATE.energy = Math.min(STATE.energy + dt * 0.8, 1.0);
                    // Jitter Effect
                    coreMesh.position.x += (Math.random()-0.5)*0.1;
                    coreMesh.position.y += (Math.random()-0.5)*0.1;
                } else if (STATE.gesture === 'RELEASE') {
                    // Explosion
                    shockwave.material.opacity = 1.0;
                    shockwave.scale.setScalar(0.1);
                    STATE.gesture = 'EXPLODING'; // Temp state
                } else if (STATE.gesture === 'EXPLODING') {
                    // Expand shockwave
                    shockwave.scale.addScalar(dt * 30.0);
                    shockwave.material.opacity -= dt * 2.0;
                    STATE.energy = Math.max(STATE.energy - dt * 5.0, 0);
                    if (shockwave.material.opacity <= 0) STATE.gesture = 'IDLE';
                } else {
                    // Decay
                    STATE.energy = Math.max(STATE.energy - dt * 0.5, 0.1);
                }
            } else {
                // Hide or reset
                STATE.energy = 0;
                coreMesh.visible = false;
                lightning.visible = false;
                particles.visible = false;
            }

            // Visual Update based on energy
            const s = 0.5 + STATE.energy * 1.5;
            coreMesh.scale.setScalar(s);
            coreMesh.material.uniforms.uTime.value = time;
            coreMesh.material.uniforms.uEnergy.value = STATE.energy;

            particles.material.uniforms.uTime.value = time;
            particles.material.uniforms.uBurst.value = (STATE.gesture === 'EXPLODING') ? 1.0 : 0.0;
            particles.visible = STATE.handActive;

            // Lightning Animation
            lightning.visible = STATE.handActive && (STATE.energy > 0.3);
            lightning.children.forEach((l, i) => {
                l.rotation.z += dt * (2.0 + i);
                l.scale.setScalar(s * (1.2 + Math.sin(time*10+i)*0.2));
            });

            // UI Update
            document.getElementById('energy-bar').style.width = (STATE.energy * 100) + '%';

            composer.render();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();
    </script>
</body>
</html>
