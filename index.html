<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avengers Level VFX - Debug Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; transform: scaleX(-1); }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        #console {
            background: rgba(0,0,0,0.8); color: #00ff00; padding: 10px;
            max-height: 150px; overflow-y: auto; font-size: 12px;
            pointer-events: auto; width: 300px; border: 1px solid #00ff00;
            margin: 10px;
        }

        #start-btn {
            pointer-events: auto;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; background: #bd00ff; color: white; border: none;
            font-size: 20px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 20px #bd00ff; display: none;
            z-index: 100;
        }

        #status-bar {
            text-align: center; padding: 20px; color: #00ffff;
            font-size: 24px; text-shadow: 0 0 10px #00ffff;
            text-transform: uppercase; letter-spacing: 4px;
        }

        video { display: none; }
    </style>

    <!-- AI Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js Import -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui">
        <div id="console">
            <div>> SYSTEM BOOT...</div>
        </div>
        <button id="start-btn">INITIALIZE SYSTEM</button>
        <div id="status-bar">WAITING FOR INPUT</div>
    </div>

    <video id="input-video" playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Logger
        function log(msg) {
            const c = document.getElementById('console');
            const div = document.createElement('div');
            div.innerText = `> ${msg}`;
            c.appendChild(div);
            c.scrollTop = c.scrollHeight;
            console.log(msg);
        }

        // Configuration
        const CONFIG = {
            colors: {
                core: new THREE.Color(0xffffff),
                inner: new THREE.Color(0xaa00ff), 
                lightning: new THREE.Color(0x00ffff)
            }
        };

        let scene, camera, renderer, composer;
        let coreOrb, lightningGroup;
        let videoElement, hands;
        let isTracking = false;

        // --- 1. SETUP THREE.JS (SAFE MODE) ---
        function initThree() {
            try {
                log("Initializing 3D Engine...");
                
                scene = new THREE.Scene();
                
                // Camera setup for webcam match
                camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.z = 5;

                // Safe Renderer Settings (Prevents Context Loss)
                renderer = new THREE.WebGLRenderer({ 
                    antialias: false, // OFF for performance
                    alpha: true,
                    powerPreference: "default" // Avoids forcing GPU crash
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                document.body.appendChild(renderer.domElement);

                // Post Processing (Bloom)
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    2.0, 0.5, 0.1
                );
                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                log("3D Engine Ready.");
                createVisuals();
                
                // Show Start Button
                document.getElementById('start-btn').style.display = 'block';
                document.getElementById('start-btn').addEventListener('click', startSystem);

            } catch (e) {
                log("CRITICAL ERROR: " + e.message);
            }
        }

        // --- 2. CREATE VISUALS (Simple but Effective) ---
        function createVisuals() {
            // A. The Energy Orb
            const geo = new THREE.IcosahedronGeometry(0.5, 10);
            const mat = new THREE.MeshBasicMaterial({ 
                color: CONFIG.colors.inner,
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            coreOrb = new THREE.Mesh(geo, mat);
            
            // Add a glow sphere inside
            const glowGeo = new THREE.IcosahedronGeometry(0.3, 10);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            coreOrb.add(new THREE.Mesh(glowGeo, glowMat));
            
            scene.add(coreOrb);
            coreOrb.visible = false; // Hide until hand found

            // B. Lightning Group
            lightningGroup = new THREE.Group();
            scene.add(lightningGroup);
        }

        // --- 3. START SYSTEM (Camera + AI) ---
        async function startSystem() {
            document.getElementById('start-btn').style.display = 'none';
            log("Requesting Camera Access...");

            videoElement = document.getElementById('input-video');

            try {
                // Initialize MediaPipe Hands
                hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onHandResults);

                // Start Camera
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 1280,
                    height: 720
                });
                
                log("Starting Camera Stream...");
                await cameraUtils.start();
                log("System Active. Show Hands.");
                
                // Add Video Background
                const vidTex = new THREE.VideoTexture(videoElement);
                vidTex.colorSpace = THREE.SRGBColorSpace;
                const bg = new THREE.Mesh(
                    new THREE.PlaneGeometry(16, 9).scale(1.3, 1.3, 1),
                    new THREE.MeshBasicMaterial({ map: vidTex, depthWrite: false })
                );
                bg.position.z = -10;
                scene.add(bg);

                animate(); // Start Render Loop

            } catch (e) {
                log("CAMERA ERROR: " + e.message);
                log("Did you allow camera permission?");
            }
        }

        // --- 4. GESTURE LOGIC ---
        function onHandResults(results) {
            isTracking = true;
            lightningGroup.clear(); // Clear old lines

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                
                // Process Hand 1
                const lm = results.multiHandLandmarks[0];
                const thumb = lm[4];
                const index = lm[8];

                // Map Coordinates
                const x = (0.5 - index.x) * 14;
                const y = (0.5 - index.y) * 8;
                const z = -index.z * 5;

                // Pinch Calculation
                const dx = (0.5 - thumb.x) * 14;
                const dy = (0.5 - thumb.y) * 8;
                const dist = Math.sqrt(Math.pow(x-dx, 2) + Math.pow(y-dy, 2));

                // Position Orb between thumb and index
                coreOrb.visible = true;
                coreOrb.position.set((x+dx)/2, (y+dy)/2, z);
                
                // Scale based on pinch distance (0.1 to 2.0)
                const scale = Math.max(0.2, dist * 3.0);
                coreOrb.scale.setScalar(scale);
                coreOrb.rotation.z += 0.1;
                coreOrb.rotation.y += 0.1;

                document.getElementById('status-bar').innerText = "ENERGY ACTIVE";

                // Generate Lightning if pinch is open
                if (scale > 1.0) {
                    createLightning(coreOrb.position, scale);
                }

                // Dual Hand Logic
                if (results.multiHandLandmarks.length === 2) {
                    const lm2 = results.multiHandLandmarks[1];
                    const x2 = (0.5 - lm2[8].x) * 14;
                    const y2 = (0.5 - lm2[8].y) * 8;
                    
                    document.getElementById('status-bar').innerText = "DUAL SYNC";
                    createBridge(coreOrb.position, new THREE.Vector3(x2, y2, z));
                }

            } else {
                coreOrb.visible = false;
                document.getElementById('status-bar').innerText = "SCANNING...";
            }
        }

        // --- 5. VISUAL HELPERS ---
        function createLightning(center, scale) {
            // Create random jagged lines coming out of the core
            const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
            
            for(let i=0; i<5; i++) {
                const points = [];
                points.push(center);
                
                // Random end point
                const ex = center.x + (Math.random()-0.5) * scale * 3;
                const ey = center.y + (Math.random()-0.5) * scale * 3;
                const ez = center.z + (Math.random()-0.5);
                
                // Midpoint jitter
                const mx = (center.x + ex)/2 + (Math.random()-0.5);
                const my = (center.y + ey)/2 + (Math.random()-0.5);
                
                points.push(new THREE.Vector3(mx, my, ez));
                points.push(new THREE.Vector3(ex, ey, ez));
                
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geo, material);
                lightningGroup.add(line);
            }
        }

        function createBridge(p1, p2) {
            // Electric arc between hands
            const material = new THREE.LineBasicMaterial({ color: 0xff00ff });
            const points = [];
            const steps = 10;
            
            for(let i=0; i<=steps; i++) {
                const t = i/steps;
                const tx = THREE.MathUtils.lerp(p1.x, p2.x, t);
                const ty = THREE.MathUtils.lerp(p1.y, p2.y, t);
                const tz = THREE.MathUtils.lerp(p1.z, p2.z, t);
                
                // Add noise
                const jitter = (Math.random() - 0.5) * 0.5;
                points.push(new THREE.Vector3(tx, ty + jitter, tz));
            }
            
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geo, material);
            lightningGroup.add(line);
        }

        // --- 6. RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            composer.render();
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Run
        initThree();

    </script>
</body>
</html>
